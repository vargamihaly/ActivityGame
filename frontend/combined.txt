// File: vite.config.ts
--------------------------------------------------------------------------------
import * as path from 'path';
import react from '@vitejs/plugin-react'
import { defineConfig } from 'vite'

export default defineConfig({
    plugins: [react()],
    resolve: {
        alias: {
            "@": path.resolve(__dirname, "./src"),
        },
    },
    server: {
        port: 5173,
        proxy: {
            '/api': {
                target: 'https://localhost:8082',
                changeOrigin: true,
                secure: false,
            },
            '/hubs': {
                target: 'http://localhost:8081',  // HTTP for SignalR
                ws: true,
                changeOrigin: true,
            },
        },
    },
    base: '/',
})

// File: postcss.config.js
--------------------------------------------------------------------------------
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


// File: tailwind.config.js
--------------------------------------------------------------------------------
/** @type {import('tailwindcss').Config} */
export default {
    darkMode: ["class"],
    content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
  	extend: {
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
        typography: {
            DEFAULT: {
                css: {
                    h1: {
                        color: '#1f2937',
                        fontWeight: '700',
                    },
                    p: {
                        color: '#4b5563',
                    },
                },
            },
        },
  		colors: {}
  	}
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
}

// File: src\theme.ts
--------------------------------------------------------------------------------
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
    // Customize your theme here
});

export default theme;

// File: src\App.test.js
--------------------------------------------------------------------------------
import { render, screen } from '@testing-library/react';
import App from './App.tsx';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


// File: src\reportWebVitals.js
--------------------------------------------------------------------------------
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


// File: src\setupTests.js
--------------------------------------------------------------------------------
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


// File: src\App.tsx
--------------------------------------------------------------------------------
import React, {useState} from 'react';
import {Routes, Route, Navigate, useNavigate} from 'react-router-dom';
import {AuthProvider} from './context/AuthContext';
import {ProtectedRoute} from './components/ProtectedRoute';
import {GameProvider} from './context/GameContext';
import Layout from './components/Layout';
import Login from "@/components/Login/Login";
import Main from "@/components/Main/Main";
import Lobby from "@/components/Lobby/Lobby";
import Game from "@/components/Game/Game";
import GameStats from "@/components/GameStats/GameStats";
import ErrorBoundary from "@/ErrorBoundary";
import {QueryClient, QueryClientProvider} from "@tanstack/react-query";
import {ReactQueryDevtools} from "@tanstack/react-query-devtools";

const App: React.FC = () => {

    const [queryClient] = useState(() => new QueryClient());

    return (
        <QueryClientProvider client={queryClient}>
            <ErrorBoundary>
                <AuthProvider>
                    <GameProvider>
                        <Layout>
                            <Routes>
                                <Route path="/login" element={<Login/>}/>
                                <Route path="/" element={<ProtectedRoute><Main/></ProtectedRoute>}/>
                                <Route path="/lobby/:gameId" element={<ProtectedRoute><Lobby/></ProtectedRoute>}/>
                                <Route path="/game/:gameId" element={<ProtectedRoute><Game/></ProtectedRoute>}/>
                                <Route path="/game-stats/:gameId"
                                       element={<ProtectedRoute><GameStats/></ProtectedRoute>}/>
                                <Route path="*" element={<Navigate to="/"/>}/>
                            </Routes>
                        </Layout>
                    </GameProvider>
                </AuthProvider>
            </ErrorBoundary>
            <ReactQueryDevtools initialIsOpen={false}/>
        </QueryClientProvider>
    );
};

export default App;

// File: src\ErrorBoundary.tsx
--------------------------------------------------------------------------------
import React, { ErrorInfo, ReactNode } from 'react';

interface ErrorBoundaryProps {
    children: ReactNode;
}

interface ErrorBoundaryState {
    hasError: boolean;
}

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
    constructor(props: ErrorBoundaryProps) {
        super(props);
        this.state = { hasError: false };
    }

    static getDerivedStateFromError(_: Error): ErrorBoundaryState {
        return { hasError: true };
    }

    componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        console.error('ErrorBoundary caught an error:', error, errorInfo);
    }

    render() {
        if (this.state.hasError) {
            console.log('ErrorBoundary: Rendering error state');
            return <h1>Something went wrong.</h1>;
        }

        console.log('ErrorBoundary: Rendering children');
        return this.props.children;
    }
}

export default ErrorBoundary;

// File: src\main.tsx
--------------------------------------------------------------------------------
import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter as Router } from 'react-router-dom'
import { GoogleOAuthProvider } from '@react-oauth/google'
import { ThemeProvider } from '@mui/material/styles'
import CssBaseline from '@mui/material/CssBaseline'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

import App from './App'
import theme from './theme'
import './index.css'

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <GoogleOAuthProvider clientId="303304165561-7lclve1c4ohh4ghn9t0l2ss0heeu3raq.apps.googleusercontent.com">
            <ThemeProvider theme={theme}>
                <CssBaseline />
                <QueryClientProvider client={queryClient}>
                <Router>
                    <App />
                </Router>
                </QueryClientProvider>
            </ThemeProvider>
        </GoogleOAuthProvider>
    </React.StrictMode>,
)


// File: src\api\games-api.ts
--------------------------------------------------------------------------------
import axios, { AxiosResponse, AxiosRequestConfig } from 'axios';
import { components } from "@/api/activitygame-schema";
import { CONFIG } from "@/config/config";

// Define types
type CreateGameResponseApiResponse = components['schemas']['CreateGameResponseApiResponse'];
type ApiResponse = components['schemas']['ApiResponse'];
type StartGameResponseApiResponse = components['schemas']['StartGameResponseApiResponse'];
type GetGameResponseApiResponse = components['schemas']['GameResponseApiResponse'];
type EndTurnResponseApiResponse = components['schemas']['EndTurnResponseApiResponse'];
type EndTurnRequest = components['schemas']['EndTurnRequest'];
type UpdateGameSettingsRequest = components['schemas']['UpdateGameSettingsRequest'];
type SetUsernameRequest = components['schemas']['SetUsernameRequest'];
type UserResponseApiResponse = components['schemas']['UserResponseApiResponse'];
type GlobalStatisticsResponseApiResponse = components['schemas']['GetGlobalStatisticsResponseApiResponse'];
type UserStatisticsResponseApiResponse = components['schemas']['GetUserStatisticsResponseApiResponse'];

let authToken: string | null = null;

const axiosClient = axios.create({
    baseURL: CONFIG.activityGameApi.endpoint,
    timeout: CONFIG.activityGameApi.timeout,
    withCredentials: CONFIG.activityGameApi.withCredentials,
});

axiosClient.interceptors.request.use((config) => {
    if (authToken) {
        config.headers['Authorization'] = `Bearer ${authToken}`;
    }
    return config;
});

export const setAuthToken = (token: string | null) => {
    authToken = token;
};


const API_PATHS = {
    register: '/Auth/register',
    me: '/Auth/me',
    logout: '/Auth/logout',
    username: '/Auth/username',
    gameEvents: '/GameEvents',
    games: '/games',
    globalStatistics: '/statistics/statistics/global',
    userStatistics: '/statistics/statistics/user',
} as const;

const apiCall = async <T>(method: 'get' | 'post' | 'put' | 'patch', url: string, data?: any): Promise<AxiosResponse<T>> => {
    const config: AxiosRequestConfig = { method, url };
    if (data) {
        config.data = data;
    }
    return await axiosClient(config);
};

// Auth endpoints
export const postRegisterAsync = async (): Promise<UserResponseApiResponse> => {
    const response = await apiCall<UserResponseApiResponse>('post', API_PATHS.register);
    return response.data;
};

export const getMeAsync = async (): Promise<UserResponseApiResponse> => {
    const response = await apiCall<UserResponseApiResponse>('get', API_PATHS.me);
    return response.data;
};

export const postLogoutAsync = async (): Promise<ApiResponse> => {
    const response = await apiCall<ApiResponse>('post', API_PATHS.logout);
    return response.data;
};

//not used atm
export const postUsernameAsync = async (request: SetUsernameRequest): Promise<UserResponseApiResponse> => {
    const response = await apiCall<UserResponseApiResponse>('post', API_PATHS.username, request);
    return response.data;
};

// Game events endpoint
export const connectToGameEventStreamAsync = async (gameId: string): Promise<EventSource> => {
    const response = await apiCall<void>('get', `${API_PATHS.gameEvents}/${gameId}`);

    if (response.status !== 200) {
        throw new Error(`Failed to connect to game event stream. Status: ${response.status}`);
    }

    const eventSource = new EventSource(`${CONFIG.activityGameApi.endpoint}${API_PATHS.gameEvents}/${gameId}`);
    return eventSource;
};

// Game endpoints
export const getGameDetailsAsync = async (gameId: string): Promise<GetGameResponseApiResponse> => {
    const response = await apiCall<GetGameResponseApiResponse>('get', `${API_PATHS.games}/${gameId}`);
    return response.data;
};

export const getCurrentGameAsync = async (): Promise<GetGameResponseApiResponse> => {
    const response = await apiCall<GetGameResponseApiResponse>('get', `${API_PATHS.games}/current`);
    return response.data;
};

export const postCreateGameAsync = async (): Promise<CreateGameResponseApiResponse> => {
    const response = await apiCall<CreateGameResponseApiResponse>('post', API_PATHS.games);
    return response.data;
};

export const postJoinGameAsync = async (gameId: string): Promise<ApiResponse> => {
    const response = await apiCall<ApiResponse>('post', `${API_PATHS.games}/${gameId}/join`);
    return response.data;
};

export const postStartGameAsync = async (gameId: string): Promise<StartGameResponseApiResponse> => {
    const response = await apiCall<StartGameResponseApiResponse>('post', `${API_PATHS.games}/${gameId}/start`);
    return response.data;
};

export const postLeaveLobbyAsync = async (gameId: string): Promise<ApiResponse> => {
    const response = await apiCall<ApiResponse>('post', `${API_PATHS.games}/${gameId}/lobby/leave`);
    return response.data;
};

export const postLeaveGameAsync = async (gameId: string): Promise<ApiResponse> => {
    const response = await apiCall<ApiResponse>('post', `${API_PATHS.games}/${gameId}/leave`);
    return response.data;
};

export const postEndTurnAsync = async (gameId: string, request: EndTurnRequest): Promise<EndTurnResponseApiResponse> => {
    const response = await apiCall<EndTurnResponseApiResponse>('post', `${API_PATHS.games}/${gameId}/turns/end`, request);
    return response.data;
};

export const updateGameSettingsAsync = async (gameId: string, request: UpdateGameSettingsRequest): Promise<ApiResponse> => {
    const response = await apiCall<ApiResponse>('patch', `${API_PATHS.games}/${gameId}/settings`, request);
    return response.data;
};

export const getGlobalStatisticsAsync = async (): Promise<GlobalStatisticsResponseApiResponse> => {
    const response = await apiCall<GlobalStatisticsResponseApiResponse>('get', API_PATHS.globalStatistics);
    return response.data;
};

export const getUserStatisticsAsync = async (): Promise<UserStatisticsResponseApiResponse> => {
    const response = await apiCall<UserStatisticsResponseApiResponse>('get', API_PATHS.userStatistics);
    return response.data;
};

export const postTimeUpAsync = async (gameId: string): Promise<ApiResponse> => {
    const response = await apiCall<ApiResponse>('post', `${API_PATHS.games}/${gameId}/time-up`);
    return response.data;
};

// File: src\components\Layout.tsx
--------------------------------------------------------------------------------
import React from 'react';
import { Link as RouterLink, useLocation, useNavigate } from 'react-router-dom';
import { useAuth } from '@/context/AuthContext';
import { useGame } from '@/context/GameContext';
import { Button } from "@/components/ui/button"
import { LogOut, Home, ArrowLeft } from 'lucide-react'
import { Toaster } from "@/components/ui/toaster";
import { GAME_STATUS } from "@/interfaces/GameTypes";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";

const Layout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const { user, logout } = useAuth();
    const { isInGame, currentGame } = useGame();
    const location = useLocation();
    const navigate = useNavigate();

    return (
        <div className="min-h-screen flex flex-col">
            <header className="bg-primary text-primary-foreground shadow-md">
                <div className="container mx-auto px-4">
                    <div className="flex items-center justify-between h-16">
                        <h1 className="text-2xl font-bold">Activity Game</h1>
                        {user && (
                            <div className="flex items-center space-x-4">
                                <div className="flex items-center mr-4">
                                    <Avatar className="h-8 w-8 mr-2">
                                        <AvatarFallback>{user.username[0]}</AvatarFallback>
                                    </Avatar>
                                    <span className="text-sm font-medium">{user.username}</span>
                                </div>
                                <nav className="flex items-center space-x-2">
                                    <Button
                                        variant={location.pathname === '/' ? 'secondary' : 'ghost'}
                                        asChild
                                    >
                                        <RouterLink to="/">
                                            <Home className="mr-2 h-4 w-4"/>
                                            Main
                                        </RouterLink>
                                    </Button>
                                    <Button variant="ghost" onClick={logout}>
                                        <LogOut className="mr-2 h-4 w-4"/>
                                        Logout
                                    </Button>
                                </nav>
                            </div>
                        )}
                    </div>
                </div>
            </header>
            <main className="flex-grow container mx-auto px-4 py-8">
                {children}
            </main>
            <Toaster/>
        </div>
    );
};

export default Layout;

// File: src\components\ProtectedRoute.tsx
--------------------------------------------------------------------------------
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '@/context/AuthContext';

export const ProtectedRoute: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const { user, loading } = useAuth();
    const location = useLocation();

    console.log("ProtectedRoute: Rendering, user:", user, "loading:", loading);

    if (loading) {
        console.log("ProtectedRoute: Still loading, showing loading indicator");
        return <div>Loading...</div>;
    }

    if (!user) {
        console.log("ProtectedRoute: No user, redirecting to login");
        return <Navigate to="/login" state={{ from: location }} replace />;
    }

    console.log("ProtectedRoute: User authenticated, rendering children");
    return <>{children}</>;
};

// File: src\components\forms\updateSettings\MaxScoreField.tsx
--------------------------------------------------------------------------------
import { TextField } from '@mui/material';
import React from "react";

interface MaxScoreFieldProps {
    value: number;
    error?: string;
    touched?: boolean;
    onChange: (value: number) => void;
    disabled?: boolean;
}

const MaxScoreField: React.FC<MaxScoreFieldProps> = ({ value, error, touched, onChange, disabled }) => {
    return (
        <TextField
            name="maxScore"
            label="Max Score"
            type="number"
            value={value}
            onChange={(e) => onChange(Number(e.target.value))}
            error={touched && !!error}
            helperText={touched && error}
            disabled={disabled}
        />
    );
};

export default MaxScoreField;

// File: src\components\forms\updateSettings\MethodSelection.tsx
--------------------------------------------------------------------------------
import { Checkbox, FormControlLabel, FormGroup, Typography } from '@mui/material';
import React from "react";

import {METHOD_TYPE} from "@/interfaces/GameTypes";
import {components} from "@/api/activitygame-schema";

type MethodType = components['schemas']['MethodType'];

interface MethodSelectionProps {
    methods: MethodType[];
    onToggle: (method: MethodType) => void;
    error?: string;
    touched?: boolean;
    disabled?: boolean;
}

const MethodSelection: React.FC<MethodSelectionProps> = ({ methods, onToggle, error, touched, disabled }) => {
    return (
        <>
            <Typography variant="subtitle1">Game Methods:</Typography>
            <FormGroup>
                {Object.entries(METHOD_TYPE).map(([key, value]) => (
                    <FormControlLabel
                        key={key}
                        control={
                            <Checkbox
                                name="methods"
                                checked={methods.includes(value)}
                                onChange={() => onToggle(value)}
                                disabled={disabled}
                            />
                        }
                        label={key}
                    />
                ))}
            </FormGroup>
            {touched && error && <Typography color="error">{error}</Typography>}
        </>
    );
};

export default MethodSelection;

// File: src\components\forms\updateSettings\TimerField.tsx
--------------------------------------------------------------------------------
import { TextField } from '@mui/material';
import React from "react";

interface TimerFieldProps {
    value: number;
    error?: string;
    touched?: boolean;
    onChange: (value: number) => void;
    disabled?: boolean;
}

const TimerField: React.FC<TimerFieldProps> = ({ value, error, touched, onChange, disabled }) => {
    return (
        <TextField
            name="timer"
            label="Timer (minutes)"
            type="number"
            value={value}
            onChange={(e) => onChange(Number(e.target.value))}
            error={touched && !!error}
            helperText={touched && error}
            disabled={disabled}
        />
    );
};

export default TimerField;


// File: src\components\forms\updateSettings\UpdateSettingsForm.tsx
--------------------------------------------------------------------------------
import React, { useEffect } from 'react';
import { Formik, Form, useFormikContext } from 'formik';
import * as Yup from 'yup';
import { Box, Button } from '@mui/material';
import { useToast } from '@/hooks/use-toast';
import { useUpdateSettings } from '@/hooks/gameHooks';
import MaxScoreField from './MaxScoreField';
import MethodSelection from './MethodSelection';
import TimerField from "@/components/forms/updateSettings/TimerField";
import { components } from "@/api/activitygame-schema";
import {METHOD_TYPE} from "@/interfaces/GameTypes";

type MethodType = components['schemas']['MethodType'];

const SettingsSchema = Yup.object().shape({
    timer: Yup.number().min(1, 'Timer must be at least 1 minute').required('Timer is required'),
    maxScore: Yup.number().min(1, 'Max score must be at least 1').required('Max score is required'),
    methods: Yup.array().of(Yup.mixed<MethodType>().oneOf(Object.values(METHOD_TYPE))).min(1, 'At least one method must be selected').required('Methods are required'),
});

interface UpdateSettingsFormProps {
    gameId: string;
    timer: number;
    maxScore: number;
    enabledMethods: MethodType[];
    onSuccess: () => void;
    isDisabled?: boolean;
}

const FormikUpdater: React.FC<{ timer: number; maxScore: number; enabledMethods: MethodType[] }> = ({
                                                                                                        timer,
                                                                                                        maxScore,
                                                                                                        enabledMethods
                                                                                                    }) => {
    const { setFieldValue } = useFormikContext();

    useEffect(() => {
        const updateFields = async () => {
            try {
                await Promise.all([
                    setFieldValue('timer', timer || 1),
                    setFieldValue('maxScore', maxScore || 1),
                    setFieldValue('methods', enabledMethods || [])
                ]);
            } catch (error) {
                console.error('Error updating form fields:', error);
            }
        };

        updateFields();
    }, [timer, maxScore, enabledMethods, setFieldValue]);

    return null;
};

const UpdateSettingsForm: React.FC<UpdateSettingsFormProps> = ({
                                                                   gameId,
                                                                   timer,
                                                                   maxScore,
                                                                   enabledMethods,
                                                                   onSuccess,
                                                                   isDisabled = false,
                                                               }) => {
    const updateSettingsMutation = useUpdateSettings();
    const { toast } = useToast();

    return (
        <Formik
            initialValues={{
                timer: timer || 1,
                maxScore: maxScore || 1,
                methods: enabledMethods || [],
            }}
            validationSchema={SettingsSchema}
            onSubmit={async (values, { setSubmitting }) => {
                if (isDisabled) return;

                const requestPayload = {
                    timer: values.timer,
                    maxScore: values.maxScore,
                    enabledMethods: values.methods,
                };

                try {
                    await updateSettingsMutation.mutateAsync({ gameId, request: requestPayload });
                    onSuccess();
                    toast({
                        title: 'Success',
                        description: 'Game settings updated successfully!',
                    });
                } catch (error) {
                    toast({
                        title: 'Error',
                        description: `Failed to update settings: ${(error as Error).message}`,
                        variant: 'destructive',
                    });
                } finally {
                    setSubmitting(false);
                }
            }}
        >
            {({ errors, touched, isSubmitting, values, setFieldValue }) => (
                <Form>
                    <FormikUpdater timer={timer} maxScore={maxScore} enabledMethods={enabledMethods} />
                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                        <TimerField
                            value={values.timer}
                            error={errors.timer}
                            touched={touched.timer}
                            onChange={(value) => setFieldValue('timer', value)}
                            disabled={isDisabled}
                        />
                        <MaxScoreField
                            value={values.maxScore}
                            error={errors.maxScore}
                            touched={touched.maxScore}
                            onChange={(value) => setFieldValue('maxScore', value)}
                            disabled={isDisabled}
                        />
                        <MethodSelection
                            methods={values.methods}
                            onToggle={(method: MethodType) => {
                                if (isDisabled) return;
                                const newMethods = values.methods.includes(method)
                                    ? values.methods.filter((m) => m !== method)
                                    : [...values.methods, method];
                                setFieldValue('methods', newMethods);
                            }}
                            error={errors.methods as string}
                            touched={touched.methods}
                            disabled={isDisabled}
                        />
                        <Button type="submit" variant="contained" disabled={isSubmitting || isDisabled}>
                            {isSubmitting ? 'Updating...' : 'Update Settings'}
                        </Button>
                    </Box>
                </Form>
            )}
        </Formik>
    );
};

export default UpdateSettingsForm;

// File: src\components\Game\CurrentRound.tsx
--------------------------------------------------------------------------------
import React from 'react';
import { Card, CardContent } from "@/components/ui/card";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import {components} from "@/api/activitygame-schema";

type MethodType = components['schemas']['MethodType'];

interface CurrentRoundProps {
    methodType: MethodType;
    word: string;
    activePlayerUsername: string;
    isActivePlayer: boolean;
}

const CurrentRound: React.FC<CurrentRoundProps> = ({ methodType, word, activePlayerUsername, isActivePlayer }) => (
    <Card className="md:col-span-2">
        <CardContent className="p-6">
            <div className="mb-6">
                <h2 className="text-2xl font-semibold mb-3">Current Round</h2>
                <div className="bg-primary/10 p-4 rounded-lg">
                    <p className="text-lg mb-2">
                        <strong>Method:</strong> {methodType}
                    </p>
                    <p className="text-3xl font-bold text-primary">{word}</p>
                </div>
            </div>

            <div className="mb-6">
                <h3 className="text-xl font-semibold mb-2">Active Player</h3>
                <div className="flex items-center bg-secondary/20 p-3 rounded-lg">
                    <Avatar className="h-10 w-10 mr-3">
                        <AvatarFallback>{activePlayerUsername[0]}</AvatarFallback>
                    </Avatar>
                    <span className="text-lg font-medium">{activePlayerUsername}</span>
                    {isActivePlayer && (
                        <Badge
                            variant="default"
                            className="ml-auto bg-primary text-primary-foreground"
                        >
                            It's your turn!
                        </Badge>
                    )}
                </div>
            </div>
        </CardContent>
    </Card>
);

export default CurrentRound;

// File: src\components\Game\Game.tsx
--------------------------------------------------------------------------------
import React, {useCallback, useEffect, useState} from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useAuth } from '@/context/AuthContext';
import { useGame } from '@/context/GameContext';
import {useEndTurn, useGameDetails, useTimeUp} from '@/hooks/gameHooks';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Loader2, MessageCircle } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import useSSE from '@/hooks/useSSE';
import useGameTimer from '@/hooks/useGameTimer';
import CurrentRound from './CurrentRound';
import WinnerSelection from './WinnerSelection';
import TimerDisplay from './TimerDisplay';
import Leaderboard from './Leaderboard';

const Game: React.FC = () => {
    const { gameId } = useParams<{ gameId: string }>();
    const { user } = useAuth();
    const navigate = useNavigate();
    const { currentGame, setCurrentGame, setIsInGame } = useGame();
    const { toast } = useToast();
    const endTurnMutation = useEndTurn();
    const timeUpMutation = useTimeUp();
    const { data: gameDetails, refetch: reFetchGameDetails } = useGameDetails(gameId);
    const [selectedWinnerId, setSelectedWinnerId] = useState<string>('');

    // Function to refresh game details
    const refreshGameDetails = useCallback(async () => {
        await reFetchGameDetails();
    }, [reFetchGameDetails]);

    // Initialize the game timer
    const { timeLeft, progress, startTimer, resetTimer } = useGameTimer({
        initialTime: currentGame?.timerInMinutes ? currentGame.timerInMinutes * 60 : 0,
        onTimeUp: async () => {
            if (isActivePlayer) {
                try {
                    await handleTimeUp();
                    toast({
                        title: "Time's up!",
                        description: 'Starting next round...'
                    });
                } catch (error) {
                    console.error('Error handling time up:', error);
                    toast({
                        title: 'Error',
                        description: 'Failed to handle time up',
                        variant: 'destructive'
                    });
                }
            }
        },
    });

    const handleTimeUp = async () => {
        if (!gameId) return;

        try {
            await timeUpMutation.mutateAsync(gameId);
            await refreshGameDetails();
        } catch (error) {
            console.error('Error handling time up:', error);
            throw error;
        }
    };

    // Event handler when the game ends
    const onGameEnded = useCallback(() => {
        toast({
            title: 'Game Over',
            description: 'The game has ended! Redirecting to stats page...',
        });
        setIsInGame(false);
        setCurrentGame(null);
        navigate(`/game-stats/${gameId}`);
    }, [toast, setIsInGame, setCurrentGame, navigate, gameId]);

    const onTurnEnded = useCallback(() => {
        console.log('Turn ended, resetting timer and selected winner');
        resetTimer();
        setSelectedWinnerId('');
        refreshGameDetails();
    }, [resetTimer, refreshGameDetails]);

    // Set up SSE to listen to server events
    const { isConnected, error: sseError } = useSSE(gameId, {
        onGameEnded,
        onTurnEnded,
        refreshGameDetails,
    });

    // Fetch game details on component mount and when gameId changes
    useEffect(() => {
        if (gameId) {
            reFetchGameDetails();
        }
    }, [gameId, reFetchGameDetails]);

    // Update currentGame state and reset/start timer when gameDetails change
    useEffect(() => {
        if (gameDetails) {
            setCurrentGame(gameDetails);
            resetTimer(gameDetails.timerInMinutes * 60);
            startTimer();
        }
    }, [gameDetails, setCurrentGame, resetTimer, startTimer]);

    // Handle ending the turn
    const handleEndTurn = async () => {
        if (!selectedWinnerId || !gameId) {
            toast({
                title: 'Error',
                description: 'Please select a winner before ending the turn.',
                variant: 'destructive',
            });
            return;
        }

        try {
            await endTurnMutation.mutateAsync({ gameId, request: { winnerUserId: selectedWinnerId } });
            toast({
                title: 'Success',
                description: 'Turn ended successfully. New turn started!',
            });
            setSelectedWinnerId('');
            refreshGameDetails();
        } catch (error) {
            console.error('Error ending turn:', error);
            toast({
                title: 'Error',
                description: 'Failed to end turn. Please try again.',
                variant: 'destructive',
            });
        }
    };

    if (!currentGame) {
        return (
            <div className="flex justify-center items-center h-screen">
                <Loader2 className="h-12 w-12 animate-spin text-primary" />
            </div>
        );
    }

    const currentRoundNumber = currentGame.currentRound?.roundNumber ?? 1;
    const isActivePlayer = user?.username === currentGame.currentRound?.activePlayerUsername;
    console.log('currentGame:', currentGame);
    console.log('isActivePlayer:', isActivePlayer);
    console.log('userId:', user?.id);
    console.log('activePlayerUsername:', currentGame.currentRound?.activePlayerUsername);

    return (
        <div className="container mx-auto p-4 max-w-6xl">
            <div className="mb-8 text-center">
                <h1 className="text-4xl font-bold mb-2">Activity Game</h1>
                <p className="text-xl text-gray-600">
                    Round {currentRoundNumber} of {currentGame.maxScore}
                </p>
                {!isConnected && (
                    <p className="text-red-500 mt-2">Disconnected from server. Attempting to reconnect...</p>
                )}
                {sseError && (
                    <p className="text-red-500 mt-2">Error: {sseError}</p>
                )}
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <div className="lg:col-span-2 space-y-6">
                    <Card>
                        <CardContent className="p-6">
                            <CurrentRound
                                methodType={currentGame.currentRound?.methodType!}
                                word={currentGame.currentRound?.word ?? ''}
                                activePlayerUsername={currentGame.currentRound?.activePlayerUsername ?? ''}
                                isActivePlayer={isActivePlayer}
                            />

                            {/* Winner Selection section - Only shown when user is the active player */}
                            {isActivePlayer && (
                                <div className="mt-6 border-t pt-6">
                                    {timeLeft > 0 ? (
                                        <WinnerSelection
                                            players={currentGame.players!}
                                            activePlayerUsername={currentGame.currentRound?.activePlayerUsername ?? ''}
                                            selectedWinnerId={selectedWinnerId}
                                            onWinnerSelect={setSelectedWinnerId}
                                            onEndTurn={handleEndTurn}
                                            isEndingTurn={endTurnMutation.isPending}
                                        />
                                    ) : (
                                        <Button
                                            onClick={handleTimeUp}
                                            className="w-full"
                                        >
                                            Start Next Round
                                        </Button>
                                    )}
                                </div>
                            )}
                        </CardContent>
                    </Card>

                    <Card>
                        <CardContent className="p-6">
                            <h3 className="text-xl font-semibold mb-4 flex items-center">
                                <MessageCircle className="mr-2 h-5 w-5" />
                                Game Chat
                            </h3>
                            <div className="bg-secondary/10 p-4 rounded-lg h-32 mb-4">
                                <p className="text-gray-500 italic">Chat functionality coming soon...</p>
                            </div>
                            <div className="flex">
                                <input
                                    type="text"
                                    placeholder="Type your message..."
                                    className="flex-grow mr-2 p-2 border rounded"
                                    disabled
                                />
                                <Button disabled>Send</Button>
                            </div>
                        </CardContent>
                    </Card>
                </div>

                <div className="space-y-6">
                    <Card>
                        <CardContent className="p-6">
                            <TimerDisplay timeLeft={timeLeft} progress={progress} />
                        </CardContent>
                    </Card>
                    <Card>
                        <CardContent className="p-6">
                            <Leaderboard players={currentGame.players ?? []} currentUserId={user?.id ?? ''} />
                        </CardContent>
                    </Card>
                </div>
            </div>
        </div>
    );
};

export default Game;

// File: src\components\Game\Leaderboard.tsx
--------------------------------------------------------------------------------
import React from 'react';
import { Card, CardContent } from "@/components/ui/card";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { Crown } from 'lucide-react';
import {components} from "@/api/activitygame-schema";

type PlayerResponse = components['schemas']['PlayerResponse'];

interface LeaderboardProps {
    players: PlayerResponse[];
    currentUserId: string;
}

const Leaderboard: React.FC<LeaderboardProps> = ({ players, currentUserId }) => (
    <Card>
        <CardContent className="p-6">
            <h3 className="text-xl font-semibold mb-4 flex items-center">
                <Crown className="mr-2 h-5 w-5"/>
                Leaderboard
            </h3>
            <ul className="space-y-3">
                {players.sort((a, b) => (b.score ?? 0) - (a.score ?? 0)).map((player, index) => (
                    <li key={player.id} className="flex items-center justify-between bg-secondary/10 p-2 rounded">
                        <div className="flex items-center">
                            <span className="font-semibold mr-2">{index + 1}.</span>
                            <Avatar className="h-8 w-8 mr-2">
                                <AvatarFallback>{player.username![0]}</AvatarFallback>
                            </Avatar>
                            <span>{player.id === currentUserId ? `${player.username} (You)` : player.username}</span>
                        </div>
                        <Badge variant={index === 0 ? "default" : "secondary"}>{player.score}</Badge>
                    </li>
                ))}
            </ul>
        </CardContent>
    </Card>
);

export default Leaderboard;

// File: src\components\Game\TimerDisplay.tsx
--------------------------------------------------------------------------------
import React from 'react';
import { Card, CardContent } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Timer } from 'lucide-react';

interface TimerDisplayProps {
    timeLeft: number;
    progress: number;
}

const TimerDisplay: React.FC<TimerDisplayProps> = ({ timeLeft, progress }) => {
    const formatTimeLeft = (seconds: number) => {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
    };

    return (
        <Card>
            <CardContent className="p-6">
                <h3 className="text-xl font-semibold mb-4 flex items-center">
                    <Timer className="mr-2 h-5 w-5"/>
                    Time Remaining
                </h3>
                <div className="text-4xl font-bold text-center mb-4">
                    {formatTimeLeft(timeLeft)}
                </div>
                <Progress value={progress} className="w-full"/>
            </CardContent>
        </Card>
    );
};

export default TimerDisplay;

// File: src\components\Game\WinnerSelection.tsx
--------------------------------------------------------------------------------
import React from 'react';
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import {components} from "@/api/activitygame-schema";

type PlayerResponse = components['schemas']['PlayerResponse'];

interface WinnerSelectionProps {
    players: PlayerResponse[];
    activePlayerUsername: string;
    selectedWinnerId: string;
    onWinnerSelect: (winnerId: string) => void;
    onEndTurn: () => void;
    isEndingTurn: boolean;
}

const WinnerSelection: React.FC<WinnerSelectionProps> = ({
                                                             players,
                                                             activePlayerUsername,
                                                             selectedWinnerId,
                                                             onWinnerSelect,
                                                             onEndTurn,
                                                             isEndingTurn
                                                         }) => (
    <div className="space-y-4">
        <Select onValueChange={onWinnerSelect}>
            <SelectTrigger className="w-full">
                <SelectValue placeholder="Select Winner"/>
            </SelectTrigger>
            <SelectContent>
                {players
                    .filter(player => player.username !== activePlayerUsername)
                    .map((player) => (
                        <SelectItem key={player.id} value={player.id!}>{player.username}</SelectItem>
                    ))}
            </SelectContent>
        </Select>

        <Button
            onClick={onEndTurn}
            disabled={!selectedWinnerId || isEndingTurn}
            className="w-full"
        >
            {isEndingTurn ? 'Ending Turn...' : 'End Turn'}
        </Button>
    </div>
);

export default WinnerSelection;

// File: src\components\GameStats\GameStats.tsx
--------------------------------------------------------------------------------
import React from 'react';
import { useParams } from 'react-router-dom';
import { useGameDetails } from "@/hooks/gameHooks";
import { Card, CardContent } from "@/components/ui/card";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { Loader2, Trophy, Clock, Target } from 'lucide-react';
import {METHOD_TYPE} from "@/interfaces/GameTypes";
import {useAuth} from "@/context/AuthContext";


const GameStats: React.FC = () => {
    const { gameId } = useParams<{ gameId: string }>();
    const { data: gameDetails, isLoading, error } = useGameDetails(gameId!);
    const { user } = useAuth();
    

    if (isLoading) {
        return (
            <div className="flex justify-center items-center h-screen">
                <Loader2 className="h-12 w-12 animate-spin text-primary" />
            </div>
        );
    }

    if (error || !gameDetails) {
        return <div className="text-center text-red-500 p-4">Error loading game statistics</div>;
    }

    const winner = gameDetails.players!.reduce((prev, current) => (prev.score! > current.score!) ? prev : current);
    const isCurrentUserWinner = user?.id === winner.id;

    return (
        <div className="container mx-auto p-4 max-w-4xl">
            <h1 className="text-4xl font-bold mb-8 text-center">Game Statistics</h1>

            <Card className="mb-6">
                <CardContent className="p-6">
                    <h2 className="text-2xl font-semibold mb-4 flex items-center">
                        <Trophy className="mr-2 h-6 w-6 text-yellow-500" />
                        Winner
                    </h2>
                    <div className={`flex flex-col items-center bg-yellow-100 p-4 rounded-lg ${isCurrentUserWinner ? 'animate-pulse' : ''}`}>
                        {isCurrentUserWinner && (
                            <div className="text-2xl font-bold text-yellow-600 mb-4 animate-bounce">
                                üéâ Congratulations! You Won! üéâ
                            </div>
                        )}
                        <div className="flex items-center">
                            <Avatar className="h-12 w-12 mr-4">
                                <AvatarFallback>{winner.username![0]}</AvatarFallback>
                            </Avatar>
                            <div>
                                <p className="text-xl font-bold">{winner.username}</p>
                                <p className="text-lg">Score: {winner.score}</p>
                            </div>
                        </div>
                        {isCurrentUserWinner && (
                            <p className="mt-4 text-center text-yellow-700">
                                Amazing job! You've proven your skills in this game! üèÜ
                            </p>
                        )}
                    </div>
                </CardContent>
            </Card>

            <Card className="mb-6">
                <CardContent className="p-6">
                    <h2 className="text-2xl font-semibold mb-4 flex items-center">
                        <Target className="mr-2 h-6 w-6" />
                        Game Details
                    </h2>
                    <ul className="space-y-2">
                        <li><strong>Max Score:</strong> {gameDetails.maxScore}</li>
                        <li><strong>Timer:</strong> {gameDetails.timerInMinutes} minutes</li>
                        <li><strong>Enabled Methods:</strong> {gameDetails.enabledMethods!.map(method => METHOD_TYPE[method]).join(', ')}</li>
                    </ul>
                </CardContent>
            </Card>

            <Card>
                <CardContent className="p-6">
                    <h2 className="text-2xl font-semibold mb-4 flex items-center">
                        <Clock className="mr-2 h-6 w-6" />
                        Final Standings
                    </h2>
                    <ul className="space-y-4">
                        {gameDetails.players!.sort((a, b) => b.score! - a.score!).map((player, index) => (
                            <li key={player.id} className="flex items-center justify-between bg-secondary/10 p-3 rounded-lg">
                                <div className="flex items-center">
                                    <span className="font-semibold mr-3">{index + 1}.</span>
                                    <Avatar className="h-10 w-10 mr-3">
                                        <AvatarFallback>{player.username![0]}</AvatarFallback>
                                    </Avatar>
                                    <span className="text-lg">{player.username}</span>
                                </div>
                                <Badge variant={index === 0 ? "default" : "secondary"} className="text-lg">
                                    {player.score}
                                </Badge>
                            </li>
                        ))}
                    </ul>
                </CardContent>
            </Card>
        </div>
    );
};

export default GameStats;

// File: src\components\Lobby\Lobby.tsx
--------------------------------------------------------------------------------
import React, {useCallback, useEffect, useState} from 'react';
import {useParams, useNavigate} from 'react-router-dom';
import {useAuth} from '@/context/AuthContext';
import {useGame} from '@/context/GameContext';
import {useStartGame, useLeaveLobby} from "@/hooks/gameHooks";
import UpdateSettingsForm from "../forms/updateSettings/UpdateSettingsForm";
import {Button} from "@/components/ui/button";
import {Card, CardContent, CardHeader, CardTitle} from "@/components/ui/card";
import {Avatar, AvatarFallback} from "@/components/ui/avatar";
import {Badge} from "@/components/ui/badge";
import {Collapsible, CollapsibleContent, CollapsibleTrigger} from "@/components/ui/collapsible";
import {Loader2, Settings, Star, LogOut} from 'lucide-react';
import {useToast} from "@/hooks/use-toast";
import {Copy} from 'lucide-react';
import useSSE from '@/hooks/useSSE';
import {components} from "@/api/activitygame-schema";

type PlayerResponse = components['schemas']['PlayerResponse'];

const Lobby: React.FC = () => {
    const {gameId} = useParams<{ gameId: string }>();
    const {user, setHostStatus} = useAuth();
    const [showSettings, setShowSettings] = useState(false);
    const {toast} = useToast();
    const startGameMutation = useStartGame();
    const leaveLobbyMutation = useLeaveLobby();
    const {currentGame, setCurrentGame, setIsInGame, refreshGameDetails} = useGame();
    const navigate = useNavigate();

    const onGameStarted = useCallback(() => {
        toast({
            title: "Game Started",
            description: "The game has begun! Redirecting to game page...",
        });
        navigate(`/game/${gameId}`);
    }, [toast, navigate, gameId]);


    const onGameSettingsUpdated = useCallback(async () => {
        await refreshGameDetails();
        toast({
            title: "Game Settings Updated",
            description: "The game settings have been updated.",
        });
    }, [refreshGameDetails, toast]);

    const onPlayerJoinedLobby = useCallback(async () => {
        await refreshGameDetails();
        toast({
            title: "New Player Joined",
            description: "A new player has joined the lobby.",
        });
    }, [refreshGameDetails, toast]);

    const onPlayerLeftLobby = useCallback(
        async (leftPlayerId: string) => {
            await refreshGameDetails();

            if (leftPlayerId === user?.id) {

                //If this user was the host, remove his host status
                setHostStatus(false);


                let isLastUserLeaving = currentGame?.players && currentGame.players.length === 0;
                if (isLastUserLeaving) {
                    // Handle game cancellation
                    toast({
                        title: "Game Cancelled",
                        description: "The game has been cancelled as there are no players left.",
                    });
                } else {
                    toast({
                        title: "You left the game",
                        description: "Redirected to the main page.",
                    });
                }

                navigate('/');

            } else {
                // Another player left
                toast({
                    title: "Player Left",
                    description: "A player has left the lobby.",
                });
            }

            if (currentGame?.players && currentGame.players.length === 0) {
                // Handle game cancellation
                toast({
                    title: "Game Cancelled",
                    description: "The game has been cancelled as there are no players left.",
                });
                navigate('/');
            }
        },
        [refreshGameDetails, user?.id, setHostStatus, currentGame?.players, toast, navigate]
    );

    const {isConnected, error} = useSSE(gameId, {
        onGameStarted,
        onPlayerJoinedLobby,
        onPlayerLeftLobby,
        onGameSettingsUpdated
    });

    useEffect(() => {
        if (error) {
            toast({
                title: "Connection Error",
                description: "There was an issue connecting to the game. We're trying to reconnect.",
                variant: "destructive",
            });
        }
    }, [error, toast]);

    useEffect(() => {
        if (gameId) {
            refreshGameDetails();
        }
    }, [gameId, refreshGameDetails]);

    const handleStartGame = async () => {
        if (!gameId) {
            toast({
                title: "Error",
                description: "Please enter a valid game ID",
                variant: "destructive",
            });
            return;
        }

        try {
            await startGameMutation.mutateAsync(gameId);
            // The navigation to the game page will be handled by the SSE event
        } catch (error) {
            toast({
                title: "Error",
                description: "Failed to start game. Please try again.",
                variant: "destructive",
            });
        }
    };

    const handleLeaveLobby = async () => {
        if (!gameId) return;

        try {
            // leave lobby
            await leaveLobbyMutation.mutateAsync(gameId);
            toast({
                title: "Leaving game",
                description: "Waiting for server confirmation...",
            });

            // Clear game context
            setCurrentGame(null);
            setIsInGame(false);

            // Finally navigate
            navigate('/');
        } catch (error) {
            toast({
                title: "Error",
                description: "Failed to leave the lobby. Please try again.",
                variant: "destructive"
            });
        }
    };

    const onGameIdClicked = async () => {
        if (!gameId) return;

        try {
            await navigator.clipboard.writeText(gameId);
            toast({
                title: "Copied",
                description: "Game ID copied to clipboard!",
                variant: "default",
            });
        } catch (err) {
            toast({
                title: "Error",
                description: "Failed to copy Game ID.",
                variant: "destructive",
            });
        }
    };

    if (!currentGame) {
        return <div>Error loading game details</div>;
    }

    const isHost = currentGame.hostId === user?.id;
    const players = currentGame.players || [];
    console.log('players:', players);
    if (currentGame.hostId && !players.some(p => p.id === currentGame.hostId)) {
        // players.unshift(currentGame.hostId);
    }

    return (
        <div className="container mx-auto p-4">
            <Card className="max-w-2xl mx-auto">
                <CardHeader>
                    <CardTitle className="text-3xl font-bold text-center">Game Lobby</CardTitle>
                    <div className="flex items-center justify-center gap-2 mt-2">
                        <Badge variant="secondary" className="px-3 py-1">
                            Game ID: {gameId}
                        </Badge>
                        <Button
                            variant="outline"
                            size="icon"
                            onClick={onGameIdClicked}
                            className="h-8 w-8"
                            title="Copy Game ID"
                        >
                            <Copy className="h-4 w-4"/>
                        </Button>
                    </div>
                    {!isConnected && (
                        <div className="text-yellow-500 text-center mt-2">
                            Connecting to game events...
                        </div>
                    )}
                </CardHeader>
                <CardContent>
                    <h2 className="text-xl font-semibold mb-4">Players:</h2>
                    {players.length > 0 ? (
                        <ul className="space-y-4">
                            {players.map((player: PlayerResponse) => (
                                <li key={player.id} className="flex items-center space-x-4">
                                    <Avatar>
                                        <AvatarFallback>{player.username![0]}</AvatarFallback>
                                    </Avatar>
                                    <div>
                                        <p className="font-medium">
                                            {player.id === user?.id ? `${player.username} (You)` : player.username}
                                        </p>
                                        <p className="text-sm text-gray-500">
                                            {player.isHost ? (
                                                <span className="flex items-center">
                                                    <Star className="h-4 w-4 mr-1 text-yellow-500"/>
                                                    Host
                                                </span>
                                            ) : 'Player'}
                                        </p>
                                    </div>
                                </li>
                            ))}
                        </ul>
                    ) : (
                        <p>No players in the game yet.</p>
                    )}
                    <div className="mt-6 space-y-4">
                        <Collapsible open={showSettings} onOpenChange={setShowSettings}>
                            <CollapsibleTrigger asChild>
                                <Button variant="outline" className="w-full">
                                    <Settings className="mr-2 h-4 w-4"/>
                                    {showSettings ? 'Hide Settings' : 'Show Settings'}
                                </Button>
                            </CollapsibleTrigger>
                            <CollapsibleContent className="mt-4">
                                <UpdateSettingsForm
                                    gameId={gameId!}
                                    timer={currentGame.timerInMinutes || 1}
                                    maxScore={currentGame.maxScore || 1}
                                    enabledMethods={currentGame.enabledMethods || []}
                                    onSuccess={async () => {
                                        await refreshGameDetails();
                                        toast({
                                            title: "Success",
                                            description: "Game settings updated successfully!"
                                        });
                                    }}
                                    isDisabled={!isHost}
                                />
                            </CollapsibleContent>
                        </Collapsible>

                        {isHost && (
                            <>
                                <Button
                                    onClick={handleStartGame}
                                    className="w-full"
                                    disabled={startGameMutation.isPending || players.length < 2}
                                >
                                    {startGameMutation.isPending ? 'Starting...' : 'Start Game'}
                                </Button>
                                <Button
                                    onClick={handleLeaveLobby}
                                    className="w-full mt-4"
                                    disabled={leaveLobbyMutation.isPending}
                                    variant="destructive"
                                >
                                    <LogOut className="mr-2 h-4 w-4"/>
                                    {leaveLobbyMutation.isPending ? 'Leaving...' : 'Leave Lobby'}
                                </Button>
                                {players.length < 2 && (
                                    <p className="text-sm text-red-500 mt-2">
                                        At least 2 players are required to start the game.
                                    </p>
                                )}
                            </>
                        )}

                        {!isHost && (
                            <Button
                                onClick={handleLeaveLobby}
                                className="w-full"
                                disabled={leaveLobbyMutation.isPending}
                                variant="destructive"
                            >
                                <LogOut className="mr-2 h-4 w-4"/>
                                {leaveLobbyMutation.isPending ? 'Leaving...' : 'Leave Lobby'}
                            </Button>
                        )}
                    </div>
                </CardContent>
            </Card>
        </div>
    );
};

export default Lobby;

// File: src\components\Login\Login.tsx
--------------------------------------------------------------------------------
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '@/context/AuthContext';
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";

const GoogleIcon: React.FC = () => (
    <svg className="mr-2 h-4 w-4" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="google" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 488 512">
        <path fill="currentColor" d="M488 261.8C488 403.3 391.1 504 248 504 110.8 504 0 393.2 0 256S110.8 8 248 8c66.8 0 123 24.5 166.3 64.9l-67.5 64.9C258.5 52.6 94.3 116.6 94.3 256c0 86.5 69.1 156.6 153.7 156.6 98.2 0 135-70.4 140.8-106.9H248v-85.3h236.1c2.3 12.7 3.9 24.9 3.9 41.4z"></path>
    </svg>
);

const Login: React.FC = () => {
    const { user, login } = useAuth();

    if (user) {
        return <Navigate to="/" />;
    }

    return (
        <div className="flex justify-center items-center min-h-screen bg-gradient-to-r from-blue-500 to-purple-600">
            <Card className="w-full max-w-md">
                <CardHeader>
                    <CardTitle className="text-3xl font-bold text-center">Activity Game</CardTitle>
                    <CardDescription className="text-center">Sign in to start playing</CardDescription>
                </CardHeader>
                <CardContent>
                    <Button
                        variant="outline"
                        onClick={login}
                        className="w-full text-lg py-6"
                        aria-label="Sign in with Google"
                    >
                        <GoogleIcon />
                        Sign in with Google
                    </Button>
                </CardContent>
            </Card>
        </div>
    );
};

export default Login;

// File: src\components\Main\GameActionCard.tsx
--------------------------------------------------------------------------------
import React from 'react';
import { Card, CardHeader, CardFooter, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { PlusCircle, Users } from 'lucide-react';

interface GameActionCardProps {
    title: string;
    description: string;
    actionText: string;
    onAction: () => void;
    isLoading: boolean;
    disabled?: boolean;
    variant?: 'create' | 'join';
}

const GameActionCard: React.FC<GameActionCardProps> = ({ disabled = false, ...props }) => {
    return (
        <Card>
            <CardHeader>
                <CardTitle>{props.title}</CardTitle>
                <CardDescription>{props.description}</CardDescription>
            </CardHeader>
            <CardFooter>
                <Button
                    className="w-full"
                    onClick={props.onAction}
                    disabled={props.isLoading || disabled}
                >
                    {props.variant === 'create' ? (
                        <PlusCircle className="mr-2 h-4 w-4" />
                    ) : (
                        <Users className="mr-2 h-4 w-4" />
                    )}
                    {props.isLoading ? `${props.actionText}...` : props.actionText}
                </Button>
            </CardFooter>
        </Card>
    );
};

export default GameActionCard;


// File: src\components\Main\JoinGameDialog.tsx
--------------------------------------------------------------------------------
import React from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';
import {Input} from "@/components/ui/input";
import { Button } from '@/components/ui/button';

interface JoinGameDialogProps {
    open: boolean;
    joinGameId: string;
    onOpenChange: (open: boolean) => void;
    onJoinGameIdChange: (value: string) => void;
    onJoinGame: () => void;
    isJoining: boolean;
}

const JoinGameDialog: React.FC<JoinGameDialogProps> = ({
                                                           open,
                                                           joinGameId,
                                                           onOpenChange,
                                                           onJoinGameIdChange,
                                                           onJoinGame,
                                                           isJoining
                                                       }) => {
    return (
        <Dialog open={open} onOpenChange={onOpenChange}>
            <DialogContent>
                <DialogHeader>
                    <DialogTitle>Join Game</DialogTitle>
                </DialogHeader>
                <Input
                    placeholder="Enter game ID"
                    value={joinGameId}
                    onChange={(e) => onJoinGameIdChange(e.target.value)}
                />
                <DialogFooter>
                    <Button variant="outline" onClick={() => onOpenChange(false)}>Cancel</Button>
                    <Button
                        onClick={onJoinGame}
                        disabled={isJoining}
                    >
                        {isJoining ? 'Joining...' : 'Join'}
                    </Button>
                </DialogFooter>
            </DialogContent>
        </Dialog>
    );
};

export default JoinGameDialog;


// File: src\components\Main\Main.tsx
--------------------------------------------------------------------------------
// src/components/Main/Main.tsx
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '@/context/AuthContext';
import { useCreateGame, useJoinGame, useLeaveLobby } from "@/hooks/gameHooks";
import { useToast } from "@/hooks/use-toast";
import { useGame } from "@/context/GameContext";
import { Trophy, Users, Play, LogIn, ArrowRight } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { GAME_STATUS } from "@/interfaces/GameTypes";
import { isValidGuid } from '@/lib/guidUtils';
import { Statistics } from "@/components/Statistics/Statistics";
import JoinGameDialog from "@/components/Main/JoinGameDialog";
import UserLoading from "@/components/Main/UserLoading";

const Main: React.FC = () => {
    const navigate = useNavigate();
    const { user } = useAuth();
    const [joinGameId, setJoinGameId] = useState('');
    const [isJoinDialogOpen, setIsJoinDialogOpen] = useState(false);
    const { currentGame, isInGame, refreshGameDetails } = useGame();
    const { toast } = useToast();

    const createGameMutation = useCreateGame();
    const joinGameMutation = useJoinGame();
    const leaveLobbyMutation = useLeaveLobby();

    const handleLeaveLobby = async (gameId: string) => {
        try {
            await leaveLobbyMutation.mutateAsync(gameId);
            console.log('Left lobby successfully');
        } catch (error) {
            console.error('Error leaving lobby:', error);
            toast({
                title: "Error",
                description: "Failed to leave current lobby",
                variant: "destructive",
            });
        }
    };

    const confirmLobbyAction = async (): Promise<boolean> => {
        if (!isInGame || !currentGame || currentGame.status !== GAME_STATUS.Waiting) {
            return true;
        }

        const confirmed = window.confirm(
            "You are already in a lobby. This action will remove you from the current lobby. Continue?"
        );

        if (confirmed) {
            await handleLeaveLobby(currentGame.id);
        }

        return confirmed;
    };

    const handleCreateGame = async () => {
        if (isInGame && currentGame?.status === GAME_STATUS.InProgress) {
            toast({
                title: "Active Game in Progress",
                description: "Please finish or leave your current game first.",
                variant: "destructive",
            });
            return;
        }

        if (!(await confirmLobbyAction())) {
            return;
        }

        createGameMutation.mutate(undefined, {
            onSuccess: async (response) => {
                const gameId = response.data?.gameId;
                if (gameId) {
                    await refreshGameDetails();
                    navigate(`/lobby/${gameId}`);
                }
            },
            onError: () => {
                toast({
                    title: "Error",
                    description: "Failed to create game",
                    variant: "destructive",
                });
            }
        });
    };

    const handleJoinGame = async () => {
        if (!isValidGuid(joinGameId)) {
            toast({
                title: "Invalid Game ID",
                description: "Please enter a valid game ID",
                variant: "destructive",
            });
            return;
        }

        if (isInGame && currentGame?.status === GAME_STATUS.InProgress) {
            toast({
                title: "Active Game in Progress",
                description: "Please finish or leave your current game first.",
                variant: "destructive",
            });
            return;
        }

        if (!(await confirmLobbyAction())) {
            return;
        }

        joinGameMutation.mutate(joinGameId, {
            onSuccess: async () => {
                await refreshGameDetails();
                navigate(`/lobby/${joinGameId}`);
            },
            onError: () => {
                toast({
                    title: "Error",
                    description: "Failed to join game",
                    variant: "destructive",
                });
            }
        });
    };

    const handleReturnToGame = () => {
        if (!currentGame) return;

        const path = currentGame.status === GAME_STATUS.InProgress
            ? `/game/${currentGame.id}`
            : `/lobby/${currentGame.id}`;
        navigate(path);
    };

    if (!user) return <UserLoading />;

    return (
        <div className="max-w-6xl mx-auto p-6 space-y-8">
            {/* Welcome Section */}
            <div className="text-center space-y-2">
                <h1 className="text-3xl font-bold text-gray-900">Welcome back, {user.username}</h1>
                <p className="text-gray-600">Ready for your next challenge?</p>
            </div>

            {/* Active Game Alert */}
            {isInGame && currentGame && (
                <Card className="border-blue-200 bg-blue-50">
                    <CardHeader className="pb-2">
                        <CardTitle className="text-lg font-medium text-blue-900">
                            Active Game Session
                        </CardTitle>
                    </CardHeader>
                    <CardContent>
                        <div className="flex items-center justify-between">
                            <div className="space-y-1">
                                <p className="text-blue-900">Status: {currentGame.status}</p>
                                <p className="text-sm text-blue-700">Game ID: {currentGame.id}</p>
                            </div>
                            <Button
                                onClick={handleReturnToGame}
                                className="bg-blue-600 hover:bg-blue-700"
                            >
                                Return to Game
                                <ArrowRight className="ml-2 h-4 w-4" />
                            </Button>
                        </div>
                    </CardContent>
                </Card>
            )}

            {/* Statistics Section */}
            <div className="mb-8">
                <Statistics />
            </div>

            {/* Game Actions */}
            <div className="grid md:grid-cols-2 gap-6">
                <Card className="hover:shadow-lg transition-shadow">
                    <CardContent className="p-6">
                        <div className="space-y-4">
                            <div className="flex items-center space-x-3">
                                <div className="p-2 bg-blue-100 rounded-lg">
                                    <Play className="w-6 h-6 text-blue-600" />
                                </div>
                                <h3 className="text-xl font-semibold">Create New Game</h3>
                            </div>
                            <p className="text-gray-600">Start a new game and invite your friends to join.</p>
                            <Button
                                onClick={handleCreateGame}
                                className="w-full"
                                disabled={isInGame && currentGame?.status === GAME_STATUS.InProgress || createGameMutation.isPending}
                            >
                                Create Game
                            </Button>
                        </div>
                    </CardContent>
                </Card>

                <Card className="hover:shadow-lg transition-shadow">
                    <CardContent className="p-6">
                        <div className="space-y-4">
                            <div className="flex items-center space-x-3">
                                <div className="p-2 bg-green-100 rounded-lg">
                                    <Users className="w-6 h-6 text-green-600" />
                                </div>
                                <h3 className="text-xl font-semibold">Join Existing Lobby</h3>
                            </div>
                            <p className="text-gray-600">Enter a game ID to join a lobby.</p>
                            <Button
                                onClick={() => setIsJoinDialogOpen(true)}
                                className="w-full bg-green-600 hover:bg-green-700"
                                disabled={isInGame && currentGame?.status === GAME_STATUS.InProgress}
                            >
                                Join Game
                            </Button>
                        </div>
                    </CardContent>
                </Card>
            </div>

            <JoinGameDialog
                open={isJoinDialogOpen}
                joinGameId={joinGameId}
                onOpenChange={setIsJoinDialogOpen}
                onJoinGameIdChange={setJoinGameId}
                onJoinGame={handleJoinGame}
                isJoining={joinGameMutation.isPending}
            />
        </div>
    );
};

export default Main;

// File: src\components\Main\UserLoading.tsx
--------------------------------------------------------------------------------
import React from 'react';

const UserLoading: React.FC = () => {
    return (
        <div className="flex justify-center items-center h-screen">
            <p className="text-lg">Loading user data...</p>
        </div>
    );
};

export default UserLoading;

// File: src\components\Statistics\Statistics.tsx
--------------------------------------------------------------------------------
// src/components/Statistics/Statistics.tsx
import React from 'react';
import { useGlobalStatistics, useUserStatistics } from "@/hooks/gameHooks";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Trophy, User, Users } from 'lucide-react';
import { Loader2 } from 'lucide-react';

export const Statistics: React.FC = () => {
    const {
        data: globalStats,
        isLoading: isGlobalLoading
    } = useGlobalStatistics();
    const {
        data: userStats,
        isLoading: isUserLoading
    } = useUserStatistics();

    if (isGlobalLoading || isUserLoading) {
        return (
            <div className="flex justify-center items-center p-4">
                <Loader2 className="h-8 w-8 animate-spin" />
            </div>
        );
    }

    return (
        <div className="grid gap-4 md:grid-cols-2">
            {userStats && (
                <Card>
                    <CardHeader>
                        <CardTitle className="flex items-center gap-2">
                            <User className="h-5 w-5" />
                            Your Statistics
                        </CardTitle>
                    </CardHeader>
                    <CardContent>
                        <div className="space-y-2">
                            <p>Games Played: {userStats.gamesPlayed}</p>
                            <p>Games Won: {userStats.gamesWon}</p>
                            <p>Win Rate: {userStats.winRate}%</p>
                            <p>Average Score: {userStats.averageScore}</p>
                        </div>
                    </CardContent>
                </Card>
            )}

            {globalStats && (
                <Card>
                    <CardHeader>
                        <CardTitle className="flex items-center gap-2">
                            <Users className="h-5 w-5" />
                            Global Statistics
                        </CardTitle>
                    </CardHeader>
                    <CardContent>
                        <div className="space-y-4">
                            <div>
                                <p>Average Score: {globalStats.averageScore}</p>
                                <p>Win Rate: {globalStats.winRate}%</p>
                            </div>

                            <div>
                                <h4 className="font-semibold flex items-center gap-2 mb-2">
                                    <Trophy className="h-4 w-4 text-yellow-500" />
                                    Top Players
                                </h4>
                                <div className="space-y-2">
                                    {globalStats.playerRankings!.map((player, index) => (
                                        <div key={player.username} className="flex justify-between items-center">
                                            <span>{index + 1}. {player.username}</span>
                                            <span className="font-medium">{player.totalScore}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </CardContent>
                </Card>
            )}
        </div>
    );
};

// File: src\config\config.ts
--------------------------------------------------------------------------------
import { z } from 'zod'

const configSchema = z.object({
  activityGameApi: z.object({
    endpoint: z.string(),
    timeout: z.number(),
    withCredentials: z.boolean(),
  }),
})

export type Config = z.infer<typeof configSchema>

let CONFIG: Config;

try {
  CONFIG = configSchema.parse({
    activityGameApi: {
      endpoint: '/api', // This will always be correct due to the Vite proxy
      timeout: 40000,
      withCredentials: true,
    },
  })
} catch (error) {
  console.error('Configuration error:', error);
  throw error;
}

export { CONFIG };

// File: src\context\AuthContext.tsx
--------------------------------------------------------------------------------
import React, { createContext, ReactNode, useContext, useEffect, useState } from "react";
import { useGoogleLogin } from "@react-oauth/google";
import { getMeAsync, postLogoutAsync, postRegisterAsync, setAuthToken } from "@/api/games-api";
import { useToast } from "@/hooks/use-toast";
import {components} from "@/api/activitygame-schema";
type UserResponseApiResponse = components["schemas"]["UserResponseApiResponse"];

interface User {
    email: string;
    id: string;
    isHost: boolean;
    score: number;
    username: string;
}


interface AuthContextType {
    user: User | null;
    loading: boolean;
    login: () => void;
    logout: () => void;
    setHostStatus: (isHost: boolean) => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<User | null>(null);
    const [loading, setLoading] = useState(true);
    const { toast } = useToast();

    const setHostStatus = (isHost: boolean) => {
        setUser(prevUser =>
            prevUser ? { ...prevUser, data: { ...prevUser, isHost } } : null
        );
    };

    const login = useGoogleLogin({
        onSuccess: async (tokenResponse) => {
            try {
                setAuthToken(tokenResponse.access_token);
                const backendResponse = await postRegisterAsync();
                console.log("Backend response:");
                console.log(backendResponse);
                const response = await getMeAsync();
                console.log("AuthProvider: getMe response", response.data);
                console.log("AuthProvider1: getMe response", response);
                const userData = (response as UserResponseApiResponse);
                if (userData.success) {
                    setUser(userData.data as User);
                    toast({
                        title: "Login Successful",
                        description: "You have successfully logged in.",
                        variant: "default"
                    });
                }
                if (!userData.success) {
                    console.log("Error registering user:", userData.message);
                    setAuthToken(null);
                    toast({
                        title: "Login Failed",
                        description: "An error occurred during login. Please try again.",
                        variant: "destructive"
                    });
                }
            } catch (error) {
                console.error('Error registering user:', error);
                setAuthToken(null);
                toast({
                    title: "Login Failed",
                    description: "An error occurred during login. Please try again.",
                    variant: "destructive"
                });
            }
        },
        onError: (error) => {
            console.error('Google Login Failed:', error);
            toast({
                title: "Google Login Failed",
                description: "An error occurred during Google login. Please try again.",
                variant: "destructive"
            });
        },
    });

    const logout = async () => {
        try {
            await postLogoutAsync();
            setUser(null);
            setAuthToken(null);
            toast({
                title: "Logout Successful",
                description: "You have been logged out successfully.",
                variant: "default"
            });
        } catch (error) {
            console.error('Error logging out:', error);
            toast({
                title: "Logout Error",
                description: "An error occurred during logout. Please try again.",
                variant: "destructive"
            });
        }
    };

    useEffect(() => {
        const checkAuth = async () => {
            console.log("AuthProvider: Checking authentication");
            setLoading(true);
            try {
                const response = await getMeAsync();
                console.log("AuthProvider: getMe response", response.data);
                setUser(response.data as User);
            } catch (error) {
                console.error('AuthProvider: Error checking authentication:', error);
                setUser(null);
                setAuthToken(null);
            } finally {
                setLoading(false);
                console.log("AuthProvider: Authentication check complete, loading:", false);
            }
        };
        checkAuth();
    }, []);

    console.log("AuthProvider: Rendering, user:", user, "loading:", loading);

    return (
        <AuthContext.Provider value={{ user, loading, login, logout, setHostStatus }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (context === undefined) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};

// File: src\context\GameContext.tsx
--------------------------------------------------------------------------------
// src/context/GameContext.tsx

import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { components } from '@/api/activitygame-schema';
import { getCurrentGameAsync } from '@/api/games-api';
import { GAME_STATUS } from "@/interfaces/GameTypes";

type Game = components['schemas']['GameResponse'] | null;

interface GameContextType {
    currentGame: Game;
    setCurrentGame: React.Dispatch<React.SetStateAction<Game>>;
    isInGame: boolean;
    setIsInGame: React.Dispatch<React.SetStateAction<boolean>>;
    refreshGameDetails: () => Promise<void>;
    clearGameState: () => void;
}

const GameContext = createContext<GameContextType | undefined>(undefined);

export const GameProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [currentGame, setCurrentGame] = useState<Game | null>(null);
    const [isInGame, setIsInGame] = useState<boolean>(false);

    const refreshGameDetails = useCallback(async () => {
        try {
            const getGameResponse = await getCurrentGameAsync();
            console.log('getGameResponse:', getGameResponse);
            if (getGameResponse && getGameResponse.data) {
                if (getGameResponse.data.status === GAME_STATUS.Finished) {
                    setCurrentGame(null);
                    setIsInGame(false);
                } else {
                    setCurrentGame(getGameResponse.data);
                    setIsInGame(true);
                }
            } else {
                setCurrentGame(null);
                setIsInGame(false);
            }
        } catch (error) {
            console.error('Error refreshing game details:', error);
            setCurrentGame(null);
            setIsInGame(false);
        }
    }, [setCurrentGame, setIsInGame]);

    const clearGameState = useCallback(() => {
        setCurrentGame(null);
        setIsInGame(false);
    }, []);

    useEffect(() => {
        refreshGameDetails();
    }, [refreshGameDetails]);

    return (
        <GameContext.Provider value={{ currentGame, setCurrentGame, isInGame, setIsInGame, refreshGameDetails, clearGameState}}>
            {children}
        </GameContext.Provider>
    );
};

export const useGame = (): GameContextType => {
    const context = useContext(GameContext);
    if (context === undefined) {
        throw new Error('useGame must be used within a GameProvider');
    }
    return context;
};


// File: src\hooks\use-toast.ts
--------------------------------------------------------------------------------
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }


// File: src\hooks\useGameTimer.ts
--------------------------------------------------------------------------------
import { useState, useEffect, useCallback } from 'react';

interface UseGameTimerProps {
    initialTime: number;
    onTimeUp?: () => void;
}

const useGameTimer = ({ initialTime, onTimeUp }: UseGameTimerProps) => {
    const [timeLeft, setTimeLeft] = useState(initialTime);
    const [isActive, setIsActive] = useState(false);
    const [progress, setProgress] = useState(100);

    const startTimer = useCallback(() => setIsActive(true), []);
    const pauseTimer = useCallback(() => setIsActive(false), []);
    const resetTimer = useCallback((newTime: number = initialTime) => {
        setTimeLeft(newTime);
        setProgress(100);
        setIsActive(false);
    }, [initialTime]);

    useEffect(() => {
        let interval: NodeJS.Timeout | null = null;

        if (isActive && timeLeft > 0) {
            interval = setInterval(() => {
                setTimeLeft((prevTime) => {
                    const newTime = prevTime - 1;
                    setProgress((newTime / initialTime) * 100);
                    return newTime;
                });
            }, 1000);
        } else if (timeLeft === 0) {
            onTimeUp?.();
        }

        return () => {
            if (interval) clearInterval(interval);
        };
    }, [isActive, timeLeft, initialTime, onTimeUp]);

    return { timeLeft, progress, startTimer, pauseTimer, resetTimer };
};

export default useGameTimer;

// File: src\hooks\useSSE.ts
--------------------------------------------------------------------------------
import { useEffect, useState } from 'react';

interface UseSSEOptions {
    onGameStarted?: () => void;
    onGameEnded?: () => void;
    onTurnEnded?: () => void;
    onPlayerLeftLobby?: (leftPlayerId: string) => void;
    onGameSettingsUpdated?: () => void;
    onPlayerJoinedLobby?: () => void;
    refreshGameDetails?: () => Promise<void>;
}

const useSSE = (
    gameId: string | undefined,
    options: UseSSEOptions = {}
) => {
    const {
        onGameStarted,
        onGameEnded,
        onTurnEnded,
        onPlayerLeftLobby,
        onGameSettingsUpdated,
        onPlayerJoinedLobby,
        refreshGameDetails,
    } = options;
    const [isConnected, setIsConnected] = useState(false);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        if (!gameId) return;

        let isCancelled = false;
        const eventSource = new EventSource(`/api/GameEvents/${gameId}`);

        eventSource.onopen = () => {
            if (isCancelled) return;
            setIsConnected(true);
            setError(null);
            console.log('SSE connection established');
        };

        eventSource.onmessage = async (event) => {
            if (isCancelled) return;
            try {
                const data = JSON.parse(event.data);
                console.log('SSE message - event:', event);
                console.log('SSE message - event.data:', data);
                switch (data.event) {
                    case 'TurnEnded':
                        onTurnEnded && onTurnEnded();
                        break;
                    case 'GameEnded':
                        onGameEnded && onGameEnded();
                        break;
                    case 'PlayerLeftLobby':
                        onPlayerLeftLobby && onPlayerLeftLobby(data.data);
                        break;
                    case 'GameStarted':
                        onGameStarted && onGameStarted();
                        break;
                    case 'GameSettingsUpdated':
                        onGameSettingsUpdated && onGameSettingsUpdated();
                        break;
                    case 'UserJoinedLobby':
                        onPlayerJoinedLobby && onPlayerJoinedLobby();
                        break;
                    default:
                        refreshGameDetails && (await refreshGameDetails());
                        break;
                }
            } catch (err) {
                console.error('Error parsing SSE message:', err);
                setError('Error parsing server message');
            }
        };

        eventSource.onerror = (event) => {
            if (isCancelled) return;
            console.error('SSE Error:', event);
            setIsConnected(false);
            setError('Server connection lost');
            eventSource.close();
        };

        return () => {
            isCancelled = true;
            eventSource.close();
        };
    }, [
        gameId,
        onGameStarted,
        onGameEnded,
        onTurnEnded,
        onPlayerLeftLobby,
        onGameSettingsUpdated,
        onPlayerJoinedLobby,
        refreshGameDetails,
    ]);

    return { isConnected, error };
};

export default useSSE;

// File: src\hooks\gameHooks.tsx
--------------------------------------------------------------------------------
import {useMutation, useQuery, useQueryClient} from '@tanstack/react-query';
import {useToast} from "@/hooks/use-toast";
import {components} from "@/api/activitygame-schema";

import {AxiosError} from "axios";
import {
    getMeAsync,
    getCurrentGameAsync,
    postLogoutAsync,
    postUsernameAsync,
    getGameDetailsAsync,
    postCreateGameAsync,
    postEndTurnAsync,
    postStartGameAsync,
    postJoinGameAsync,
    postLeaveLobbyAsync,
    getUserStatisticsAsync,
    getGlobalStatisticsAsync,
    postTimeUpAsync, updateGameSettingsAsync
} from "@/api/games-api";
import {useGame} from "@/context/GameContext";


const errorMessageTitle = "An error occurred";

type CreateGameResponseApiResponse = components["schemas"]["CreateGameResponseApiResponse"];
type UpdateGameSettingsRequest = components["schemas"]["UpdateGameSettingsRequest"];
type ApiResponse = components["schemas"]["ApiResponse"];
type StartGameResponseApiResponse = components["schemas"]["StartGameResponseApiResponse"];
type GetGameResponseApiResponse = components["schemas"]["GameResponseApiResponse"];
type GetGameResponse = components["schemas"]["GameResponse"];
type EndTurnResponseApiResponse = components["schemas"]["EndTurnResponseApiResponse"];
type EndTurnRequest = components["schemas"]["EndTurnRequest"];
type UserResponseApiResponse = components["schemas"]["UserResponseApiResponse"];
type UserResponse = components["schemas"]["UserResponse"];
type SetUsernameRequest = components["schemas"]["SetUsernameRequest"];
type GlobalStatisticsResponse = components["schemas"]["GetGlobalStatisticsResponse"];
type UserStatisticsResponse = components["schemas"]["GetUserStatisticsResponse"];


export const useCreateGame = () => {
    const queryClient = useQueryClient();
    const {toast} = useToast();

    return useMutation<CreateGameResponseApiResponse, AxiosError<ApiResponse>, void>({
        mutationFn: postCreateGameAsync,
        onSuccess: async (response) => {
            if (response.success) {
                const gameId = response.data?.gameId;
                if (gameId) {
                    await queryClient.invalidateQueries({
                        queryKey: ['games', gameId]
                    });
                }
                console.log('Game created successfully', response.data);
            }
        },
        onError: (error) => {
            console.error('Error creating game:', error);
            const errorMessage = error.response?.data?.message || error.message || "An unexpected error occurred. Please try again.";
            toast({
                title: "An Error Occurred",
                description: errorMessage,
                variant: "destructive"
            });
        }
    });
};

export const useUpdateSettings = () => {
    const queryClient = useQueryClient();
    const {toast} = useToast();

    return useMutation<ApiResponse, AxiosError<ApiResponse>, { gameId: string; request: UpdateGameSettingsRequest }>({
        mutationFn: async ({gameId, request}) => updateGameSettingsAsync(gameId, request),
        onSuccess: async (_, {gameId}) => {
            await queryClient.invalidateQueries({
                queryKey: ['games', gameId]
            });
        },
        onError: (error) => {
            const errorMessage = error.response?.data?.message || error.message || "An unexpected error occurred.";
            toast({title: "Error", description: errorMessage, variant: "destructive"});
        }
    });
};

export const useLeaveLobby = () => {
    const queryClient = useQueryClient();
    const {toast} = useToast();

    return useMutation<ApiResponse, AxiosError<ApiResponse>, string>({
        mutationFn: postLeaveLobbyAsync,
        onSuccess: async (response, gameId) => {
            await queryClient.invalidateQueries({
                queryKey: ['games', gameId]
            });
            console.log('Left lobby successfully', response);
        },
        onError: (error) => {
            const errorMessage = error.response?.data?.message || error.message || "An unexpected error occurred while leaving the lobby.";
            toast({
                title: "Error Leaving Lobby",
                description: errorMessage,
                variant: "destructive"
            });
        }
    });
};

export const useJoinGame = () => {
    const queryClient = useQueryClient();
    const {toast} = useToast();

    return useMutation<ApiResponse, AxiosError<ApiResponse>, string>({
        mutationFn: postJoinGameAsync,
        onSuccess: async (response, gameId) => {
            await queryClient.invalidateQueries({
                queryKey: ['games', gameId]
            });
            console.log('Joined game successfully', response);
        },
        onError: (error) => {
            const errorMessage = error.response?.data?.message || error.message || "An unexpected error occurred while joining the game.";
            toast({
                title: "Error Joining Game",
                description: errorMessage,
                variant: "destructive"
            });
        }
    });
};

export const useLogout = () => {
    const queryClient = useQueryClient();
    const {toast} = useToast();

    return useMutation<ApiResponse, AxiosError<ApiResponse>, void>({
        mutationFn: postLogoutAsync,
        onSuccess: async () => {
            // Clear all queries when logging out
            await queryClient.clear();
        },
        onError: (error) => {
            const errorMessage = error.response?.data?.message || error.message || "An unexpected error occurred while logging out.";
            toast({
                title: "Logout Error",
                description: errorMessage,
                variant: "destructive"
            });
        }
    });
};

export const useGetMe = (options = {}) => {
    const {toast} = useToast();

    return useQuery<UserResponse, AxiosError<ApiResponse>>({
        queryKey: ['me'],
        queryFn: async (): Promise<UserResponse> => {

            const response = await getMeAsync();

            if (!response.data) {
                const errorMessage = response.message || "Failed to fetch user details.";
                toast({title: errorMessageTitle, description: errorMessage});
                throw new Error(errorMessage);
            }

            return response.data;
        },
        ...options,
    });
};

export const useSetUsername = () => {
    const queryClient = useQueryClient();
    const {toast} = useToast();

    return useMutation<UserResponseApiResponse, AxiosError<ApiResponse>, SetUsernameRequest>({
        mutationFn: postUsernameAsync,
        onSuccess: async () => {
            await queryClient.invalidateQueries({queryKey: ['me']});
        },
        onError: (error) => {
            const errorMessage = error.response?.data?.message || error.message || "Failed to update username.";
            toast({
                title: "Error",
                description: errorMessage,
                variant: "destructive"
            });
        }
    });
};

export const useCurrentGame = (options = {}) => {
    const {toast} = useToast();
    const {currentGame, setCurrentGame, setIsInGame} = useGame();
    const currentGameId = currentGame?.id;
    return useQuery<GetGameResponse, AxiosError<ApiResponse>>({
        queryKey: ['currentGame'],
        queryFn: async (): Promise<GetGameResponse> => {
            if (!currentGameId) {
                throw new Error('Game ID is required');
            }

            const response = await getCurrentGameAsync();

            if (!response.data) {
                const errorMessage = response.message || "Game details not found";
                toast({title: errorMessageTitle, description: errorMessage});
                throw new Error(errorMessage);
            }

            return response.data;
        },
        ...options,
    });
};

//Should not be called directly for state manage the CURRENT game, use GameContext instead
export const useGameDetails = (gameId?: string, options = {}) => {
    const {toast} = useToast();

    return useQuery<GetGameResponse, AxiosError<ApiResponse>>({
        queryKey: ['games', gameId],
        queryFn: async (): Promise<GetGameResponse> => {
            if (!gameId) {
                throw new Error('Game ID is required');
            }

            const response = await getGameDetailsAsync(gameId);

            if (!response.data) {
                const errorMessage = response.message || "Game details not found";
                toast({title: errorMessageTitle, description: errorMessage});
                throw new Error(errorMessage);
            }

            return response.data;
        },
        ...options,
    });
};

export const useStartGame = () => {
    const queryClient = useQueryClient();
    const {toast} = useToast();

    return useMutation<StartGameResponseApiResponse, AxiosError<ApiResponse>, string>({
        mutationFn: postStartGameAsync,
        onSuccess: async (_, gameId) => {
            await queryClient.invalidateQueries({
                queryKey: ['games', gameId]
            });
        },
        onError: (error) => {
            const errorMessage = error.response?.data?.message || error.message || "An unexpected error occurred.";
            toast({title: errorMessageTitle, description: errorMessage});
            throw error;
        }
    });
};


export const useEndTurn = () => {
    const queryClient = useQueryClient();
    const {toast} = useToast();

    return useMutation<EndTurnResponseApiResponse, AxiosError<ApiResponse>, {
        gameId: string;
        request: EndTurnRequest
    }>({
        mutationFn: async ({gameId, request}) => postEndTurnAsync(gameId, request),
        onSuccess: async (_, {gameId}) => {
            await queryClient.invalidateQueries({
                queryKey: ['games', gameId],
            });
        },
        onError: (error) => {
            const errorMessage = error.response?.data?.message || error.message || "An unexpected error occurred.";
            toast({title: errorMessageTitle, description: errorMessage});
            throw error;
        },
    });
};

export const useGlobalStatistics = (options = {}) => {
    const { toast } = useToast();

    return useQuery<GlobalStatisticsResponse, AxiosError<ApiResponse>>({
        queryKey: ['globalStatistics'],
        queryFn: async (): Promise<GlobalStatisticsResponse> => {
            const response = await getGlobalStatisticsAsync();

            if (!response.data) {
                const errorMessage = response.message || "Failed to fetch global statistics";
                toast({ title: errorMessageTitle, description: errorMessage });
                throw new Error(errorMessage);
            }

            return response.data;
        },
        ...options,
    });
};

export const useUserStatistics = (options = {}) => {
    const { toast } = useToast();

    return useQuery<UserStatisticsResponse, AxiosError<ApiResponse>>({
        queryKey: ['userStatistics'],
        queryFn: async (): Promise<UserStatisticsResponse> => {
            const response = await getUserStatisticsAsync();

            if (!response.data) {
                const errorMessage = response.message || "Failed to fetch user statistics";
                toast({ title: errorMessageTitle, description: errorMessage });
                throw new Error(errorMessage);
            }

            return response.data;
        },
        ...options,
    });
};

export const useTimeUp = () => {
    const queryClient = useQueryClient();
    const {toast} = useToast();

    return useMutation<ApiResponse, AxiosError<ApiResponse>, string>({
        mutationFn: postTimeUpAsync,
        onSuccess: async (_, gameId) => {
            await queryClient.invalidateQueries({
                queryKey: ['games', gameId]
            });
            console.log('Time up handled successfully');
        },
        onError: (error) => {
            const errorMessage = error.response?.data?.message || error.message || "An unexpected error occurred while handling time up.";
            toast({
                title: errorMessageTitle,
                description: errorMessage,
                variant: "destructive"
            });
            throw error;
        }
    });
};

// File: src\interfaces\GameTypes.ts
--------------------------------------------------------------------------------
import {components} from "@/api/activitygame-schema";

type GameStatus = components["schemas"]["GameStatus"];
type MethodType = components["schemas"]["MethodType"];

export const GAME_STATUS: Record<GameStatus, GameStatus> = {
    Waiting: "Waiting",
    InProgress: "InProgress",
    Finished: "Finished"
};

export const METHOD_TYPE: Record<MethodType, MethodType> = {
    Drawing: "Drawing",
    Description: "Description",
    Mimic: "Mimic"
};


// File: src\lib\guidUtils.ts
--------------------------------------------------------------------------------
/**
 * guidUtils.ts
 * Utility functions for working with GUIDs.
 */

/**
 * Regular expression for validating GUIDs.
 * Matches the pattern: 8-4-4-4-12 hexadecimal characters.
 */
const GUID_REGEX = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;

/**
 * Validates if a given string is a valid GUID.
 * @param guid The string to validate as a GUID.
 * @returns True if the string is a valid GUID, false otherwise.
 */
export const isValidGuid = (guid: string): boolean => {
    return GUID_REGEX.test(guid);
};

/**
 * Throws an error if the provided string is not a valid GUID.
 * @param guid The string to validate as a GUID.
 * @throws Error if the string is not a valid GUID.
 */
export const validateGuid = (guid: string): void => {
    if (!isValidGuid(guid)) {
        throw new Error(`Invalid GUID: ${guid}`);
    }
};

/**
 * Generates a random GUID.
 * Note: This is a simple implementation and may not be suitable for cryptographic purposes.
 * @returns A randomly generated GUID string.
 */
export const generateGuid = (): string => {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0,
            v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
};

/**
 * Formats a string as a GUID if it's valid.
 * @param input The string to format as a GUID.
 * @returns The formatted GUID if valid, or null if invalid.
 */
export const formatAsGuid = (input: string): string | null => {
    const clean = input.replace(/[^0-9a-fA-F]/g, '');
    if (clean.length !== 32) return null;

    const parts = [
        clean.substr(0, 8),
        clean.substr(8, 4),
        clean.substr(12, 4),
        clean.substr(16, 4),
        clean.substr(20, 12)
    ];

    const formatted = parts.join('-');
    return isValidGuid(formatted) ? formatted : null;
};

// File: src\lib\utils.ts
--------------------------------------------------------------------------------
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

// Tailwind CSS classnames
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}




